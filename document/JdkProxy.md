#### Java动态代理分析

##### 相关类和接口
要了解Java动态代理的机制，首先需要了解以下相关的类和接口：
1. java.lang.reflect.Proxy: 这是Java动态代理机制的主类，它提供了一组静态方法来为一组接口动态地生成代理类及其对象；
2. java.lang.reflect.InvocationHandler: 这是调用处理器接口，它自定义了一个invoke方法，用于几种处理动态处理类对象
上的方法调用。通常在该方法中实现对委托类的代理访问。
3. java.lang.ClassLoader：Proxy静态方法生成动态处理类同样通过类装载器来进行装载才能使用，它与普通类的唯一区别就是其
字节码是由JVM在运行时动态生成的而非预存在于任何一个.class文件中。

##### 特点
动态生成的代理类本身的一些特点
1. 包：如果所代理的接口都是public的，那么它将被定义在顶层包（即包路径为空），如果所代理的接口中有非publci的接口（因为
接口不能被定义为protect或private，所以除public之外就是默认的package访问级别），那么它将被定义在该接口所在包，这样设计
的目的是为了最大程度的保证动态代理类不会因为包管理的问题而无法被成功定位并访问；
2. 类修饰符：该代理类具有final和public修饰符，意味着它可以被所有的类访问，但是不能被再度继承；
3. 类名：格式是“$ProxyN”，其中N是一个逐一递增的阿拉伯数字，代表Proxy类第N次生成动态代理类，值得注意一点是，并不是
每次调用Proxy的静态方法创建动态代理类都会使得N值增加，原因是如果对同一组接口（包括接口排列的顺序相同）试图重复创建动态
代理类，它会很聪明地返回先前已经创建好的代理类的类对象，而不会再尝试去创建一个全新的代理类，这样可以节省不必要的代码重复
生成，提高了代理类的创建效率。
4. 类继承关系：Proxy 类是它的父类，这个规则适用于所有由 Proxy 创建的动态代理类。而且该类还实现了其所代理的一组接口;

代理类实例的一些特点
1. 每个实例都会关联一个InvocationHandler(调用处理器对象)，在代理类实例上调用其代理接口中声明的方法时，
最终都会由InvocationHandler的invoke方法执行；
2. java.lang.Object中有三个方法也同样会被分派到调用处理器的 invoke 方法执行，
它们是 hashCode，equals 和 toString；

美中不足
Proxy只能对interface进行代理，无法实现对class的动态代理。观察动态生成的代理继承关系图可知原因，
他们已经有一个固定的父类叫做Proxy，Java语法限定其不能再继承其他的父类

![](C:\Users\hexi\Pictures\20170412201807733.png)